{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/App.vue?6dac","webpack:///../shared/constants/window-names.js","webpack:///../shared/libs/launch-source-service.js","webpack:///../shared/libs/running-game-service.js","webpack:///../shared/libs/utils-service.js","webpack:///../shared/libs/windows-service.js","webpack:///../shared/constants/hotkeys-ids.js","webpack:///../shared/libs/hotkeys-service.js","webpack:///../shared/constants/events.js","webpack:///../shared/libs/gep-service.js","webpack:///../shared/libs/event-bus.js","webpack:///src/App.vue","webpack:///./src/App.vue?a7d1","webpack:///./src/App.vue","webpack:///./src/main.js"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","Object","prototype","hasOwnProperty","call","installedChunks","push","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","_vm","this","_h","$createElement","_c","_self","staticRenderFns","BACKGROUND","DESKTOP","MAIN","IN_GAME","NOTIFICATION","_launchSource","_detectLaunchSource","source","_getUrlParameterByName","regex","results","replace","RegExp","exec","location","search","decodeURIComponent","getLaunchSource","_gameRunningChangedListeners","_init","overwolf","games","onGameInfoUpdated","removeListener","_onGameInfoUpdated","addListener","event","gameRunning","runningChanged","gameChanged","gameInfo","isRunning","listener","isGameRunning","_isGameRunning","Promise","resolve","getRunningGameInfo","runningGameInfo","addGameRunningChangedListener","callback","getMonitorsList","reject","utils","displays","e","obtainWindow","windows","obtainDeclaredWindow","response","status","_getCurrentWindow","getCurrentWindow","restore","dragMove","id","minimize","changeSize","windowId","width","height","getStartupWindowName","launchSource","launchSourceService","WindowNames","runningGameService","getOpenWindows","close","windowName","getWindowState","state","window_state_ex","changePosition","left","top","changePositionCenter","utilsService","monitors","windowWidth","windowHeight","monitorWidth","monitorHeight","parseInt","TOGGLE","_getHotkey","hotkeyId","settings","getHotKey","hotkey","setTimeout","_setHotkey","action","registerHotKey","console","error","getToggleHotkey","HOTKEYS","setToggleHotkey","addHotkeyChangeListener","OnHotKeyChanged","LIST","REQUIRED_FEATURES","EVENTS","REGISTER_RETRY_TIMEOUT","INPUT_TRACKING_LIST","registerToGEP","eventsListener","infoListener","inputListener","events","setRequiredFeatures","log","onNewEvents","onInfoUpdates2","input","inputTracking","_listeners","eventHandler","trigger","eventName","component","Vue","config","productionTip","render","h","App","$mount"],"mappings":"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","file":"js/app.5ed49852.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"app\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\"div\")}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","export default {\n  BACKGROUND: 'background',\n  DESKTOP: 'desktop',\n  MAIN: 'main',\n  IN_GAME: 'in_game',\n  NOTIFICATION: 'notification'\n};\n","/**\n * Detects the launch source of the app (manual or automatic from game launch)\n * gamelaunchevent source means the app was autolaunched with the game\n */\n\nlet _launchSource = _detectLaunchSource();\n\nfunction _detectLaunchSource() {\n    let source = _getUrlParameterByName('source');\n    return source;\n}\n\nfunction _getUrlParameterByName(name) {\n    let regex,\n        results;\n    name = name.replace(/[\\[]/, '\\\\[')\n    .replace(/[\\]]/, '\\\\]');\n    regex = new RegExp('[\\\\?&]' + name + '=([^&#]*)');\n    results = regex.exec(location.search);\n    return results === null ? '' : decodeURIComponent(results[1].replace(/\\+/g, ' '));\n}\n\nfunction getLaunchSource() {\n    return _launchSource;\n}\n\nexport default {\n    getLaunchSource,\n};\n","/**\n * Detect whether a game is currently running\n */\nlet _gameRunningChangedListeners = [];\n\nfunction _init() {\n    overwolf.games.onGameInfoUpdated.removeListener(_onGameInfoUpdated);\n    overwolf.games.onGameInfoUpdated.addListener(_onGameInfoUpdated);\n}\n\n/**\n * A game info was updated (running state, or other state changed such as\n * resolution changed)\n * @param event\n * @private\n */\nfunction _onGameInfoUpdated(event) {\n    let gameRunning;\n\n    if (event &&\n        (event.runningChanged || event.gameChanged)) {\n        gameRunning = (event.gameInfo && event.gameInfo.isRunning);\n        for (let listener of _gameRunningChangedListeners) {\n            listener(gameRunning);\n        }\n    }\n}\n\nasync function isGameRunning() {\n    let gameRunning = await _isGameRunning();\n    return gameRunning;\n}\n\nfunction _isGameRunning() {\n    return new Promise((resolve => {\n        // get the current running game info if any game is running\n        overwolf.games.getRunningGameInfo(function (runningGameInfo) {\n            if (runningGameInfo && runningGameInfo.isRunning) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n        });\n    }));\n}\n\nfunction addGameRunningChangedListener(callback) {\n    _gameRunningChangedListeners.push(callback);\n}\n\n_init();\n\nexport default {\n    isGameRunning,\n    addGameRunningChangedListener,\n};\n","/**\n * Change window position\n * @returns {Promise<*>}\n */\nasync function getMonitorsList() {\n    return new Promise(async (resolve, reject) => {\n        try {\n            overwolf.utils.getMonitorsList((result) => {\n                resolve(result.displays);\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\nexport default {\n    getMonitorsList,\n};\n","import WindowNames from '../constants/window-names';\nimport launchSourceService from './launch-source-service';\nimport runningGameService from './running-game-service';\nimport utilsService from './utils-service';\n\n/**\n * obtain a window object by a name as declared in the manifest\n * this is required in order to create the window before calling other APIs\n * on that window\n * @param name\n * @returns {Promise<any>}\n */\nfunction obtainWindow(name) {\n    return new Promise((resolve, reject) => {\n        overwolf.windows.obtainDeclaredWindow(name, (response) => {\n            if (response.status !== 'success') {\n                return reject(response);\n            }\n            resolve(response);\n        });\n    });\n}\n\nfunction _getCurrentWindow() {\n    return new Promise((resolve, reject) => {\n        overwolf.windows.getCurrentWindow(result => {\n            if (result.status === 'success') {\n                resolve(result.window);\n            }\n            else {\n                reject(result);\n            }\n        });\n    });\n}\n\n/**\n * restore a window by name\n * @param name\n * @returns {Promise<any>}\n */\nfunction restore(name) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            await obtainWindow(name);\n            overwolf.windows.restore(name, (result) => {\n                if (result.status === 'success') {\n                    resolve();\n                }\n                else {\n                    reject(result);\n                }\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\n/**\n * start dragging the current window\n * @param name\n * @returns {Promise<any>}\n */\nfunction dragMove(name) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            await obtainWindow(name);\n            let window = await _getCurrentWindow();\n            overwolf.windows.dragMove(window.id, (result) => {\n                if (result.status === 'success') {\n                    resolve();\n                }\n                else {\n                    reject(result);\n                }\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\n/**\n * minimize a window by name\n * @param name\n * @returns {Promise<any>}\n */\nfunction minimize(name) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            await obtainWindow(name);\n            overwolf.windows.minimize(name, (result) => {\n                if (result.status === 'success') {\n                    resolve();\n                }\n                else {\n                    reject(result);\n                }\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\n/**\n * change window size by window id\n * @param windowId\n * @returns {Promise<any>}\n */\nfunction changeSize(windowId, width, height) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            overwolf.windows.changeSize(windowId, width, height, (result) => {\n                if (result.status === 'success') {\n                    resolve();\n                }\n                else {\n                    reject(result);\n                }\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\n/**\n * get the name of the window to show first\n * @returns {Promise<*>}\n */\nasync function getStartupWindowName() {\n    let launchSource = launchSourceService.getLaunchSource();\n\n    if (launchSource === 'gamelaunchevent') {\n        return WindowNames.IN_GAME;\n    }\n\n    let isGameRunning = await runningGameService.isGameRunning();\n    if (isGameRunning) {\n        return WindowNames.IN_GAME;\n    }\n\n    return WindowNames.DESKTOP;\n}\n\n/**\n * Returns a map (window name, object) of all open windows.\n * @returns {Promise<any>}\n */\nfunction getOpenWindows() {\n    return new Promise(async (resolve, reject) => {\n        try {\n            overwolf.windows.getOpenWindows((result) => {\n                resolve(result);\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\n/**\n * Close a window\n * @param windowName\n * @returns {Promise<any>}\n */\nfunction close(windowName) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            overwolf.windows.close(windowName, () => {\n                resolve();\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\n/**\n * get state of the window\n * @returns {Promise<*>}\n */\nasync function getWindowState(name) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            overwolf.windows.getWindowState(name, (state) => {\n                if (state.status === 'success') {\n                    resolve(state.window_state_ex);\n                }\n                else {\n                    reject(result);\n                }\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\n/**\n * Change window position\n * @returns {Promise<*>}\n */\nasync function changePosition(windowId, left, top) {\n    return new Promise(async (resolve, reject) => {\n        try {\n            overwolf.windows.changePosition(windowId, left, top, (result) => {\n                if (result.status === 'success') {\n                    resolve();\n                }\n                else {\n                    reject(result);\n                }\n            });\n        } catch (e) {\n            reject(e);\n        }\n    });\n}\n\n/**\n * Change window position to screen center\n * @returns {Promise<*>}\n */\nasync function changePositionCenter(windowId) {\n    const window = await obtainWindow(windowId);\n    const monitors = await utilsService.getMonitorsList();\n\n    const { width: windowWidth, height: windowHeight } = window.window;\n    const { width: monitorWidth, height: monitorHeight } = monitors[0];\n\n    const left = (monitorWidth / 2) - (windowWidth / 2);\n    const top = (monitorHeight / 2) - (windowHeight / 2);\n\n    return await changePosition(windowId, parseInt(left), parseInt(top));\n}\n\nexport default {\n    restore,\n    dragMove,\n    minimize,\n    getStartupWindowName,\n    obtainWindow,\n    changeSize,\n    getOpenWindows,\n    close,\n    getWindowState,\n    changePosition,\n    changePositionCenter,\n};\n","export default {\n  TOGGLE: 'sample_app_showhide',\n};\n","import HOTKEYS from '../constants/hotkeys-ids';\n\n/**\n * get a hotkey combination by hotkey id\n * @param hotkeyId\n * @param callback\n * @private\n */\nfunction _getHotkey(hotkeyId, callback) {\n    overwolf.settings.getHotKey(hotkeyId, function (result) {\n        if (!result || result.status === 'error' || !result.hotkey) {\n            setTimeout(function () {\n                _getHotkey(hotkeyId, callback);\n            }, 2000);\n        }\n        else {\n            callback(result.hotkey);\n        }\n    });\n}\n\n/**\n * set custom action for a hotkey id\n * @param hotkeyId\n * @param action\n * @private\n */\nfunction _setHotkey(hotkeyId, action) {\n    overwolf.settings.registerHotKey(hotkeyId, function (result) {\n        if (result.status === 'success') {\n            action();\n        }\n        else {\n            console.error(`[HOTKEYS SERVICE] failed to register hotkey ${hotkeyId}`);\n        }\n    });\n}\n\nfunction getToggleHotkey() {\n    return new Promise((resolve, reject) => {\n        _getHotkey(HOTKEYS.TOGGLE, function (result) {\n            resolve(result);\n        });\n    });\n}\n\nfunction setToggleHotkey(action) {\n    _setHotkey(HOTKEYS.TOGGLE, action);\n}\n\nfunction addHotkeyChangeListener(listener) {\n    overwolf.settings.OnHotKeyChanged.addListener(listener);\n}\n\nexport default {\n    getToggleHotkey,\n    setToggleHotkey,\n    addHotkeyChangeListener,\n};\n","export default {\n    LIST : ['kill',\n    'death',\n    'damage',\n    'match_info',\n    'match_state',\n    'match_end',\n    'match_start',\n    'matchState',\n    'summoner_info',\n    'gameMode',\n    'rank',\n    'me',\n    'phase',\n    'abilities',\n    'gold',\n    'minions',\n    'level',\n    'fired',\n    'announcer',\n    'info',\n    'roster',\n    'player_activity_change',\n    'team_set',\n    'replay',\n    'counters',\n    'bench',\n    'board',\n    'roundNumber',\n    'roundOutcome',\n]};\n","/**\n * Game Event Provider service\n * This will listen to events from the game provided by\n * Overwolf's Game Events Provider\n */\n\nimport EVENTS from '../constants/events';\n\n\nconst REQUIRED_FEATURES = EVENTS.LIST;\nconst REGISTER_RETRY_TIMEOUT = 10000;\nconst INPUT_TRACKING_LIST = ['onKeyUp', 'onKeyDown', 'onMouseUp', 'onMouseDown'];\n\nfunction registerToGEP(eventsListener, infoListener, inputListener) {\n    // set the features we are interested in receiving\n    overwolf.games.events.setRequiredFeatures(REQUIRED_FEATURES, function (response) {\n        if (response.status === 'error') {\n            console.log(`Failed to register to GEP, retrying in ${REGISTER_RETRY_TIMEOUT / 1000}s...`);\n            setTimeout(registerToGEP, REGISTER_RETRY_TIMEOUT, eventsListener, infoListener, inputListener);\n        }\n        else if (response.status === 'success') {\n            console.log(`Successfully registered to GEP.`);\n            // Listen to game events. We call 'removeListener' before\n            // 'addListener' to make sure we don't listen multiple times\n            overwolf.games.events.onNewEvents.removeListener(eventsListener);\n            overwolf.games.events.onNewEvents.addListener(eventsListener);\n\n            // Listen to info updates\n            overwolf.games.events.onInfoUpdates2.removeListener(infoListener);\n            overwolf.games.events.onInfoUpdates2.addListener(infoListener);\n\n            for (let input of INPUT_TRACKING_LIST) {\n                overwolf.games.inputTracking[input].removeListener(inputListener[input]);\n                overwolf.games.inputTracking[input].addListener(inputListener[input]);\n            }\n        }\n    });\n}\n\nexport default {\n    registerToGEP: registerToGEP,\n};\n","let _listeners = [];\n\nfunction addListener(eventHandler) {\n    _listeners.push(eventHandler);\n}\n\nfunction trigger(eventName, data) {\n    for (let listener of _listeners) {\n        listener(eventName, data);\n    }\n}\n\nexport default {\n    addListener: addListener,\n    trigger: trigger,\n};\n","<template>\n</template>\n\n<script>\n\n  import WindowsService from '../../shared/libs/windows-service';\n  import runningGameService from '../../shared/libs/running-game-service';\n  import WindowNames from '../../shared/constants/window-names';\n  import hotkeysService from '../../shared/libs/hotkeys-service';\n  import gepService from '../../shared/libs/gep-service';\n  import eventBus from '../../shared/libs/event-bus';\n\n    export default {\n        name: 'app',\n        components: {\n        },\n     async created() {\n        // this will be available when calling overwolf.windows.getMainWindow()\n        window.ow_eventBus = eventBus;\n        window.minimize = this.minimize;\n\n        // Handle what happens when the app is launched while already running\n        // (relaunch)\n        this._registerAppLaunchTriggerHandler();\n        // Register handlers to hotkey events\n        this._registerHotkeys();\n\n        await this._restoreLaunchWindow();\n\n        // Switch between desktop/in-game windows when launching/closing game\n        runningGameService.addGameRunningChangedListener(\n                this._onRunningGameChanged\n        );\n\n        // Listen to changes in windows\n        overwolf.windows.onStateChanged.addListener(async () => {\n          // If there's only 1 window (background) open, close the app\n          const openWindows = await WindowsService.getOpenWindows();\n          if (Object.keys(openWindows).length <= 1) {\n            window.close();\n          }\n        });\n      },\n      methods: {\n        /**\n         * Minimize all app windows\n         * @public\n         */\n        async minimize() {\n            const openWindows = await WindowsService.getOpenWindows();\n            for (let windowName in openWindows) {\n                await WindowsService.minimize(windowName);\n            }\n        }\n\n        /**\n         * Handle game opening/closing\n         * @private\n         */\n        , async _onRunningGameChanged(isGameRunning) {\n            if (isGameRunning) {\n                // Register to game events\n                gepService.registerToGEP(\n                    this.onGameEvents,\n                    this.onInfoUpdate\n                );\n                // Open in-game window\n                await WindowsService.restore(WindowNames.IN_GAME);\n                // Close desktop window\n                WindowsService.close(WindowNames.DESKTOP);\n            } else {\n                // Open desktop window\n                await WindowsService.restore(WindowNames.DESKTOP);\n                // Close in-game window\n                WindowsService.close(WindowNames.IN_GAME);\n            }\n        }\n\n        /**\n         * Open the relevant window on app launch\n         * @private\n         */\n        , async _restoreLaunchWindow() {\n            // Obtain windows and set their sizes:\n            // Desktop:\n            const desktopWindowName = await WindowsService.getStartupWindowName();\n            const desktopWindow = await WindowsService.obtainWindow(\n                desktopWindowName\n            );\n            await WindowsService.changeSize(desktopWindow.window.id, 1200, 659);\n            await WindowsService.changePositionCenter(desktopWindowName);\n            // In-Game:\n            const inGameWindow = await WindowsService.obtainWindow(\n                WindowNames.IN_GAME\n            );\n            await WindowsService.changeSize(inGameWindow.window.id, 1641, 692);\n\n            const isGameRunning = await runningGameService.isGameRunning();\n\n            // Determine which window (desktop/in-game) to display when app is launched\n            if (!isGameRunning) {\n                // Game isn't runnig, display desktop window\n                WindowsService.restore(desktopWindowName);\n            } else {\n                // Register to game events\n                gepService.registerToGEP(\n                    this.onGameEvents,\n                    this.onInfoUpdate\n                );\n                // Display in-game window\n                await WindowsService.restore(WindowNames.IN_GAME);\n                WindowsService.minimize(WindowNames.IN_GAME);\n            }\n        }\n\n        /**\n         * Display notification\n         * @private\n         */\n        , async _displayNotification(title, message, time) {\n            const data = {title, message, time};\n            const notificationWindow = await WindowsService.obtainWindow(\n                WindowNames.NOTIFICATION\n            );\n\n            await WindowsService.changeSize(WindowNames.NOTIFICATION, 320, 260);\n            await WindowsService.changePositionCenter(WindowNames.NOTIFICATION);\n\n            // Display notification\n            await WindowsService.restore(WindowNames.NOTIFICATION);\n            // Start notification timer\n            // We use a timeout to give the notification controller time to register\n            // to the event bus.\n            setTimeout(() => {\n                window.ow_eventBus.trigger(\"notification\", data);\n            }, 1000);\n        }\n\n        /**\n         * handles app launch trigger event - i.e dock icon clicked\n         * @private\n         */\n        , _registerAppLaunchTriggerHandler() {\n            overwolf.extensions.onAppLaunchTriggered.removeListener(\n                this._onAppRelaunch\n            );\n            overwolf.extensions.onAppLaunchTriggered.addListener(\n                this._onAppRelaunch\n            );\n        }\n\n        , _onAppRelaunch() {\n            WindowsService.restore(WindowNames.DESKTOP);\n        }\n\n        /**\n         * set custom hotkey behavior\n         * @private\n         */\n        , _registerHotkeys() {\n            hotkeysService.setToggleHotkey(async () => {\n                let state = await WindowsService.getWindowState(WindowNames.IN_GAME);\n                if (state === \"minimized\" || state === \"closed\") {\n                    WindowsService.restore(WindowNames.IN_GAME);\n                } else if (state === \"normal\" || state === \"maximized\") {\n                    WindowsService.minimize(WindowNames.IN_GAME);\n                }\n            });\n        }\n\n        /**\n         * Pass events to windows that are listening to them\n         * @private\n         */\n        , onGameEvents(data) {\n            console.log(data);\n            for (let event of data.events) {\n                console.log(JSON.stringify(event));\n                window.ow_eventBus.trigger(\"event\", event);\n                if (event.name === \"matchStart\") {\n                    WindowsService.restore(WindowNames.IN_GAME);\n                }\n            }\n        }\n\n        /**\n         * Pass info updates to windows that are listening to them\n         * @privates\n         */\n        , onInfoUpdate(data) {\n            window.ow_eventBus.trigger(\"info\", data);\n        }\n    }\n    }\n</script>\n\n<style>\n</style>\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--12-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=441aee0e&\"\nimport script from \"./App.vue?vue&type=script&lang=js&\"\nexport * from \"./App.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports","import Vue from 'vue'\nimport App from './App.vue'\n\nVue.config.productionTip = false\n\nnew Vue({\n  render: h => h(App),\n}).$mount('#app')\n"],"sourceRoot":""}